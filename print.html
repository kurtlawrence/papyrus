<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>papyrus book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="api.html"><strong aria-hidden="true">1.</strong> API</a></li><li><ol class="section"><li class="expanded "><a href="api.code.html"><strong aria-hidden="true">1.1.</strong> Code</a></li><li class="expanded "><a href="api.cmds.html"><strong aria-hidden="true">1.2.</strong> Commands</a></li><li class="expanded "><a href="api.output.html"><strong aria-hidden="true">1.3.</strong> Output</a></li><li class="expanded "><a href="api.linking.html"><strong aria-hidden="true">1.4.</strong> Linking</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">papyrus book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#api" id="api">API</a></h1>
<p><code>papyrus</code> offers a broad API to enable embedding and customisation. Each module which provides this
functionality has documentation and there are
<a href="https://github.com/kurtlawrence/papyrus/tree/master/papyrus/examples">examples</a>
that can be used as a guide.</p>
<h1><a class="header" href="#code" id="code">Code</a></h1>
<p>Source file and crate contents.</p>
<p>Input is parsed as Rust code using the <code>syn</code> crate. <code>papyrus</code> does not differentiate the
myriad of classications for the input, rather it categorises them into <a href="Item"><code>Item</code></a>s, <a href="Statement"><code>Statement</code></a>s,
and <a href="CrateType"><code>CrateType</code></a>s.</p>
<p><code>papyrus</code> will parse a string input into a <a href="Input"><code>Input</code></a>, and these aggregate into a <a href="SourceCode"><code>SourceCode</code></a>
structure, which flattens each input.</p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>Building some source code.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate papyrus;
</span>use papyrus::code::*;

let mut src = SourceCode::new();
src.stmts.push(StmtGrp(vec![Statement {
	expr: String::from(&quot;let a = 1&quot;),
	semi: true
    },
    Statement {
	expr: String::from(&quot;a&quot;),
	semi: false
    }
]));
<span class="boring">}
</span></code></pre></pre>
<p>Crates have some more structure around them.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate papyrus;
</span>use papyrus::code::*;

let input = &quot;extern crate a_crate as acrate;&quot;;
let cr = CrateType::parse_str(input).unwrap();

assert_eq!(&amp;cr.src_line, input);
assert_eq!(&amp;cr.cargo_name, &quot;a-crate&quot;);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#cmds" id="cmds">Cmds</a></h1>
<p>Extendable commands for REPL.</p>
<p>The REPL makes use of the crate <a href="https://crates.io/crates/cmdtree"><code>cmdtree</code></a> to handle commands
that can provide additional functionality over just a Rust REPL.
A command is prefixed by a colon (<code>:</code>) and a number of defaults. To see the commands that are
included, type <code>:help</code>.</p>
<h1><a class="header" href="#common-commands" id="common-commands">Common Commands</a></h1>
<p>There are three common commands, <code>help</code>, <code>cancel</code> or <code>c</code>, and <code>exit</code>, which can be invoked in any
class.</p>
<table><thead><tr><th>cmd</th><th>action</th></tr></thead><tbody>
<tr><td><code>help</code></td><td>displays help information for the current class</td></tr>
<tr><td><code>cancel</code></td><td>moves the class back to the command root</td></tr>
<tr><td><code>exit</code></td><td>quit the REPL</td></tr>
</tbody></table>
<p>Other commands are context based off the command tree, they can be invoked with something similar
to <code>a nested command action</code> syntax.</p>
<h1><a class="header" href="#extending-commands" id="extending-commands">Extending Commands</a></h1>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>This tutorial works through the example at
<a href="https://github.com/kurtlawrence/papyrus/blob/master/papyrus/examples/custom-cmds.rs"><code>papyrus/examples/custom-cmds.rs</code></a>.</p>
<p>To begin, start a binary project with the following scaffolding in the main source code. We define
a <code>custom_cmds</code> function that will be used to build our custom commands. To highlight the
versatility of commands, the REPL is configured to have a persistent app data through a <code>String</code>.
Notice also the method to alter the prompt name through the <code>Builder::new</code> method.</p>
<pre><pre class="playpen"><code class="language-rust no_run">#[macro_use]
extern crate papyrus;

use papyrus::cmdtree::{Builder, BuilderChain};
use papyrus::cmds::CommandResult;

<span class="boring">#[cfg(not(feature = &quot;runnable&quot;))]
</span><span class="boring">fn main() {}
</span>
<span class="boring">#[cfg(feature = &quot;runnable&quot;)]
</span>fn main() {
    // Build a REPL that will use a String as the persistent app_data.
    let mut repl = repl!(String);

    // Inject our custom commands.
    repl.data.with_cmdtree_builder(custom_cmds()).unwrap();

    // Create the persistent data.
    let mut app_data = String::new();

    // Run the REPL and collect all the output.
    let output = repl.run(papyrus::run::RunCallbacks::new(&amp;mut app_data)).unwrap();

    // Print the output.
    println!(&quot;{}&quot;, output);
}

// Define our custom commands.
// The CommandResult takes the same type as the app_data,
// in this instance it is a String. We could define it as
// a generic type but then it loses resolution to interact with
// the app_data through commands.
fn custom_cmds() -&gt; Builder&lt;CommandResult&lt;String&gt;&gt; {
    // The string defines the name and the prompt that will be used.
    Builder::new(&quot;custom-cmds-app&quot;)
}
</code></pre></pre>
<h2><a class="header" href="#echo" id="echo">Echo</a></h2>
<p>Let's begin with a simple echo command. This command takes the data after the command and prints it
to screen. All these commands will be additions to the <code>Builder::new</code>.
Adding the following action with <code>add_action</code> method, the arguments are written to the <code>Write</code>able
<code>writer</code>. The REPL provides the writer and so captures the output. <code>args</code> is passed through as a
slice of string slices, <code>cmdtree</code> provides this, and are always split on word boundaries.
Finally, <code>CommandResult::Empty</code> is returned which <code>papyrus</code> further processes. <code>Empty</code> won't do
anything but the API provides alternatives.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate papyrus;
</span><span class="boring">use papyrus::cmdtree::BuilderChain;
</span><span class="boring">use papyrus::cmds::CommandResult;
</span><span class="boring">type Builder = papyrus::cmdtree::Builder&lt;CommandResult&lt;String&gt;&gt;;
</span>Builder::new(&quot;custom-cmds-app&quot;)
    .add_action(&quot;echo&quot;, &quot;repeat back input after command&quot;, |writer, args| {
	writeln!(writer, &quot;{}&quot;, args.join(&quot; &quot;)).ok();
	CommandResult::Empty
    })
    .unwrap()
<span class="boring">;
</span><span class="boring">}
</span></code></pre></pre>
<p>Now when the binary is run the REPL runs as usual. If <code>:help</code> is entered you should see the
following output.</p>
<pre><code class="language-text">[lib] custom-cmds-app=&gt; :help
help -- prints the help messages
cancel | c -- returns to the root class
exit -- sends the exit signal to end the interactive loop
Classes:
    edit -- Edit previous input
    mod -- Handle modules
Actions:
    echo -- repeat back input after command
    mut -- Begin a mutable block of code
[lib] custom-cmds-app=&gt;
</code></pre>
<p>The <code>echo</code> command exists as a root level action, with the help message displayed. Try calling
<code>:echo Hello, world!</code> and see what it does!</p>
<h2><a class="header" href="#alter-app-data" id="alter-app-data">Alter app data</a></h2>
<p>To extend what the commands can do, lets create a command set that can convert the persistent app
data case.
The actual actions are nested under a 'class' named <code>case</code>. This means to invoke the action, one
would call it through <code>:case upper</code> or <code>:case lower</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate papyrus;
</span><span class="boring">use papyrus::cmdtree::BuilderChain;
</span><span class="boring">use papyrus::cmds::CommandResult;
</span><span class="boring">type Builder = papyrus::cmdtree::Builder&lt;CommandResult&lt;String&gt;&gt;;
</span>Builder::new(&quot;custom-cmds-app&quot;)
    .add_action(&quot;echo&quot;, &quot;repeat back input after command&quot;, |writer, args| {
	writeln!(writer, &quot;{}&quot;, args.join(&quot; &quot;)).ok();
	CommandResult::Empty
    })
    .begin_class(&quot;case&quot;, &quot;change case of app_data&quot;)
	.add_action(&quot;upper&quot;, &quot;make app_data uppercase&quot;, |_, _|
	    CommandResult::&lt;String&gt;::app_data_fn(|app_data, _repldata, _| {
		*app_data = app_data.to_uppercase();
                String::new()
	    })
	)
        .add_action(&quot;lower&quot;, &quot;make app_data lowercase&quot;, |_, _|
	    CommandResult::&lt;String&gt;::app_data_fn(|app_data, _repldata, _| {
		*app_data = app_data.to_lowercase();
                String::new()
            })
        )
    .end_class()
    .unwrap()
<span class="boring">;
</span><span class="boring">}
</span></code></pre></pre>
<p>An example output is below. To inject some data into the persistent app data, a mutable code block
must be entered first.</p>
<pre><code class="language-text">[lib] papyrus=&gt; :mut
beginning mut block
[lib] custom-cmds-app-mut=&gt; app_data.push_str(&quot;Hello, world!&quot;)
finished mutating block: ()
[lib] custom-cmds-app=&gt; app_data.as_str()
custom-cmds-app [out0]: &quot;Hello, world!&quot;
[lib] custom-cmds-app=&gt; :case upper
[lib] custom-cmds-app=&gt; app_data.as_str()
custom-cmds-app [out1]: &quot;HELLO, WORLD!&quot;
[lib] custom-cmds-app=&gt; :case lower
[lib] custom-cmds-app=&gt; app_data.as_str()
custom-cmds-app [out2]: &quot;hello, world!&quot;
</code></pre>
<h1><a class="header" href="#output" id="output">Output</a></h1>
<p>Reading and writing output.</p>
<p>The <a href="crate::repl::Repl"><code>Repl</code></a> provides mechanisms to handle the output that is produced when operating. An
<a href="crate::output::Output"><code>Output</code></a> instance is maintained in the <code>Repl</code>. This output is vector of lines of output. There
are also mechanisms on the <code>Repl</code> to listen to changes on the <code>Output</code>, such that changes can be
synchronised without needing to diff the output. This is useful in longer running operations where
displaying the output progressively is required.</p>
<h1><a class="header" href="#examples-1" id="examples-1">Examples</a></h1>
<h2><a class="header" href="#stdio" id="stdio">Stdio</a></h2>
<p>Stdio could be construed as the more simple case, but actually entails some more complexity due to
the dual nature of input and output in the terminal, whereas if input is separated from the output
rendering the <a href="api.output.html#separated-rendering">separated rendering</a> example can be implemented.</p>
<p>This tutorial works through the example at
<a href="https://github.com/kurtlawrence/papyrus/blob/master/papyrus/examples/output-stdio.rs"><code>papyrus/examples/output-stdio.rs</code></a>.</p>
<p>First start an empty binary project with two extra dependencies:
<a href="https://crates.io/crates/term_cursor">term_cursor</a> and
<a href="https://crates.io/crates/term_size">term_size</a>.</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate papyrus;
extern crate term_cursor;
extern crate term_size;

use papyrus::output::{OutputChange, Receiver};
use papyrus::repl::{EvalResult, ReadResult, Signal};
use std::io::{stdin, stdout, StdoutLock, Write};
</code></pre>
<p>Before defining the main loop, lets define some functions that will be used. The first one is one
which erases the current console line. It does this by moving to the first column in the terminal,
writing a line of spaces (' '), and then moving again to the first column. This is where the
dependencies are required.</p>
<pre><code class="language-rust ignore">/// Erases the current console line by moving to first column,
/// writing a row of spaces ' ', then setting cursor back
/// to first column.
fn erase_console_line(stdout: &amp;mut StdoutLock) {
    use term_cursor as cursor;
    let lineidx = cursor::get_pos().map(|x| x.1).unwrap_or_default();

    let width = term_size::dimensions().map(|(w, _)| w).unwrap_or_default();

    cursor::set_pos(0, lineidx).unwrap();
    (0..width).for_each(|_| write!(stdout, &quot; &quot;).unwrap());
    cursor::set_pos(0, lineidx).unwrap();
}
</code></pre>
<p>Next we define a simple fuction to read a line from stdin and return a string.</p>
<pre><code class="language-rust ignore">/// Waits for a line input from stdin.
fn read_line() -&gt; String {
    let mut buf = String::new();
    stdin().read_line(&amp;mut buf).unwrap();
    buf
}
</code></pre>
<p>And finally define a function that handles the line changes. This function does its work on a
separate thread to run asynchronously while the repl is evaluating. It receives each line change
and writes it to stdout, erasing a current line, or writing a new line if required.</p>
<pre><code class="language-rust ignore">/// This handles the writing of output changes to stdout.
fn write_output_to_stdout(rx: Receiver) -&gt; std::thread::JoinHandle&lt;()&gt; {
    std::thread::spawn(move || {
        let mut stdout = std::io::stdout();

        for chg in rx.iter() {
            match chg {
                OutputChange::CurrentLine(line) =&gt; {
                    let mut lock = stdout.lock();
                    erase_console_line(&amp;mut lock);
                    write!(&amp;mut lock, &quot;{}&quot;, line).unwrap();
                    lock.flush().unwrap();
                }
                OutputChange::NewLine =&gt; writeln!(&amp;mut stdout, &quot;&quot;).unwrap(),
            }
        }
    })
}
</code></pre>
<p>These functions can be used in a main function that handles the repl states.</p>
<pre><code class="language-rust ignore">fn main() {
    // build the repl
    let repl = repl!();

    // alias the state in the variable name.
    let mut read = repl;

    loop {
        // write the prompt, erase line first.
        {
            let stdout = stdout();
            let mut lock = stdout.lock();
            erase_console_line(&amp;mut lock);
            write!(&amp;mut lock, &quot;{}&quot;, read.prompt()).unwrap();
            lock.flush().unwrap();
        }

        // read line from stdin
        let line_input = read_line();

        // set this as the repl input
        read.line_input(&amp;line_input);

        // handle the input and get a result from it
        let read_res = read.read();

        match read_res {
            ReadResult::Read(repl) =&gt; {
                // The repl is still in a read state, continue reading
                read = repl;
            }
            ReadResult::Eval(mut eval) =&gt; {
                // The repl is ready for evaluating

                // as we want to update as input comes in,
                // we need to listen to output changes
                let rx = eval.output_listen();

                // start the output thread
                let output_thread_jh = write_output_to_stdout(rx);

                // evaluate using a unit value for data
                let EvalResult { repl, signal } = eval.eval(&amp;mut ());

                // handle the signal, other values are elided but would be
                // handled in a more complete implementation
                match signal {
                    Signal::Exit =&gt; break,
                    _ =&gt; (),
                }

                let (mut repl, _) = repl.print();

                // we have printed everything it is time to close the channel
                // it is worth testing what happens if you don't, and it should
                // highlight the reason for requiring the listening channels.
                repl.close_channel();

                // we wait for the output thread to finish to let it write out
                // the remaining lines
                output_thread_jh.join().unwrap();

                read = repl;
            }
        }
    }
}
</code></pre>
<h2><a class="header" href="#separated-rendering" id="separated-rendering">Separated Rendering</a></h2>
<p>To reduce the complexity of rendering, the output listener and listen to <em>all</em> changes, which
includes any input changes, it will get updated on calls to <code>Repl.line_input()</code>. This example shows
a naive implementation which writes to a file as it goes.</p>
<p>This tutorial works through the example at
<a href="https://github.com/kurtlawrence/papyrus/blob/master/papyrus/examples/output-file.rs"><code>papyrus/examples/output-file.rs</code></a>.</p>
<p>First start an empty binary project:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate papyrus;

use papyrus::output::{OutputChange, Receiver};
use papyrus::repl::{EvalResult, ReadResult, Signal};
use std::io::{stdin, StdoutLock, Write};
</code></pre>
<p>As before there is a <code>read_line</code> function, and we alter the output function somewhat.</p>
<pre><code class="language-rust ignore">/// Waits for a line input from stdin.
fn read_line() -&gt; String {
    let mut buf = String::new();
    stdin().read_line(&amp;mut buf).unwrap();
    buf
}

/// Write output to a file as you go. Not a very efficient implementation.
fn write_outoput_to_file(rx: Receiver) -&gt; std::thread::JoinHandle&lt;()&gt; {
    std::thread::spawn(move || {
        let mut output = String::new();
        let mut pos = 0;

        for chg in rx.iter() {
            match chg {
                OutputChange::CurrentLine(line) =&gt; {
                    output.truncate(pos);
                    output.push_str(&amp;line);
                    std::fs::write(&quot;repl-output.txt&quot;, &amp;output).unwrap();
                }
                OutputChange::NewLine =&gt; {
                    output.push('\n');
                    pos = output.len();
                }
            }
        }
    })
}
</code></pre>
<p>These functions can be used in a main function that handles the repl states.</p>
<pre><code class="language-rust ignore">fn main() {
    // build the repl
    let repl = repl!();

    // alias the state in the variable name.
    let mut read = repl;

    // as we want to update as input comes in,
    // we need to listen to output changes
    let rx = read.output_listen();

    // start the output thread
    write_outoput_to_file(rx);

    loop {
        // read line from stdin
        let line_input = read_line();

        // set this as the repl input
        read.line_input(&amp;line_input);

        // handle the input and get a result from it
        let read_res = read.read();

        read = match read_res {
            ReadResult::Read(repl) =&gt; {
                // The repl is still in a read state, continue reading
                repl
            }
            ReadResult::Eval(eval) =&gt; {
                // The repl is ready for evaluating

                // evaluate using a unit value for data
                let EvalResult { repl, signal } = eval.eval(&amp;mut ());

                // handle the signal, other values are elided but would be
                // handled in a more complete implementation
                match signal {
                    Signal::Exit =&gt; break,
                    _ =&gt; (),
                }

                let (repl, _) = repl.print();
                repl
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#linking" id="linking">Linking</a></h1>
<p>Linking an external crate and sharing data.</p>
<p>When running a REPL you might want to link an external crate.
The specific use case is a developer wants to link the crate they are working on
into the REPL for the user to be able to use.
A developer might also want to make data available to the REPL.
Papyrus has this functionality but makes some assumptions that the developer will
need to be aware of, detailed below.</p>
<h2><a class="header" href="#worked-example" id="worked-example">Worked Example</a></h2>
<p>A REPL instance should always be created by invoking the macro <code>repl!()</code>.
In the examples below this will be elided for as the documentation won't compile with the macros.
The macro accepts a type ascription (such as <code>u32</code>, <code>String</code>, <code>MyStruct</code>, etc.) which defines the generic data constraint of the REPL.
When an evaluation call is made, a mutable reference of the same type will be required to be passed through.
Papyrus uses this data to pass it (across an FFI boundary) for the REPL to access.</p>
<p>To show the functionality of linking, let's work on a crate called <code>some-lib</code>.</p>
<h3><a class="header" href="#file-setup" id="file-setup">File Setup</a></h3>
<p><em><strong>main.rs</strong></em>:</p>
<pre><pre class="playpen"><code class="language-rust no_run">#[macro_use]
extern crate papyrus;

use papyrus::prelude::*;

<span class="boring">#[cfg(not(feature = &quot;runnable&quot;))]
</span><span class="boring">fn main() {}
</span>
<span class="boring">#[cfg(feature = &quot;runnable&quot;)]
</span>fn main() {
  let mut repl = repl!();

  let d = &amp;mut ();

  repl.run(papyrus::run::RunCallbacks::new(d));
}
</code></pre></pre>
<p><em><strong>lib.rs</strong></em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct MyStruct {
  pub a: i32,
  pub b: i32,
}

impl MyStruct {
  pub fn new(a: i32, b: i32) -&gt; Self {
    MyStruct { a, b }
  }

  pub fn add_contents(&amp;self) -&gt; i32 {
    self.a + self.b
  }
}
<span class="boring">}
</span></code></pre></pre>
<p><em><strong>Cargo.toml</strong></em>:</p>
<pre><code class="language-toml">[package]
name = &quot;some-lib&quot;

...

[lib]
name = &quot;some_lib&quot;
crate-type = [&quot;rlib&quot; ]
path = &quot;src/lib.rs&quot; # you may need path to the library

[dependencies]
papyrus = { version = &quot;*&quot;, crate-type = [ &quot;rlib&quot; ] }
...
</code></pre>
<p>Notice that you will have to specify the <em>library</em> with a certain <code>crate-type</code>.
Papyrus links using an <code>rlib</code> file, but it is shown that you can also build multiple library files.
If you build this project you should find a <code>libsome_lib.rlib</code> sitting in your build directory.
Papyrus uses this to link when compiling.
The <code>papyrus</code> dependency also requires a <code>crate-type</code> specification.
If not specified, references to <code>papyrus</code> in the <em>library</em> will cause compilation errors when
running the REPL.</p>
<h3><a class="header" href="#repl" id="repl">REPL</a></h3>
<p>Run this project (<code>cargo run</code>). It should spool up fine and prompt you with <code>papyrus=&gt;</code>.
Now you can try to use the linked crate.</p>
<pre><code class="language-sh">papyrus=&gt; some_lib::MyStruct::new(20, 30).add_contents()
papyrus [out0]: 50
</code></pre>
<h2><a class="header" href="#behind-the-scenes" id="behind-the-scenes">Behind the scenes</a></h2>
<ul>
<li>Papyrus takes the crate name you specify and will add this as <code>extern crate CRATE_NAME;</code> to the source file.</li>
<li>When setting the external crate name, the <code>rlib</code> library is found and copied into the compilation directory.
<ul>
<li>Papyrus uses <code>std::env::current_exe()</code> to find the executing folder, and searches for the <code>rlib</code> file in that folder (<code>libCRATE_NAME.rlib</code>)</li>
<li>Specify the path to the <code>rlib</code> library if it is located in a different folder</li>
</ul>
</li>
<li>When compiling the REPL code, a rustc flag is set, linking the <code>rlib</code> such that <code>extern crate CRATE_NAME;</code> works.</li>
</ul>
<h2><a class="header" href="#passing-mystruct-data-through" id="passing-mystruct-data-through">Passing <code>MyStruct</code> data through</a></h2>
<p>Keep the example before, but alter the <code>main.rs</code> file.</p>
<p><em><strong>main.rs</strong></em>:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate papyrus;
extern crate some_lib;

use some_lib::MyStruct;

<span class="boring">#[cfg(not(feature = &quot;runnable&quot;))]
</span><span class="boring">fn main() {}
</span>
<span class="boring">#[cfg(feature = &quot;runnable&quot;)]
</span>fn main() {
  let mut app_data = MyStruct::new(20, 10);

  let mut repl = repl!(some_lib::MyStruct);

  repl.data = repl
    .data
    .with_extern_crate(&quot;some_lib&quot;, None)
    .expect(&quot;failed creating repl data&quot;);

  repl.run(&amp;mut app_data);
}
</code></pre>
<p>Run this project (<code>cargo run</code>).
It should spool up fine and prompt you with <code>papyrus=&gt;</code>.
Now you can try to use the linked data.
The linked data is in a variable <code>app_data</code>. It is borrowed or mutably borrowed depending on the
REPL state.</p>
<pre><code class="language-sh">papyrus=&gt; app_data.add_contents()
papyrus [out0]: 50
</code></pre>
<h2><a class="header" href="#notes" id="notes">Notes</a></h2>
<h3><a class="header" href="#panics" id="panics">Panics</a></h3>
<p>To avoid crashing the application on a panic, <code>catch_unwind</code> is employed.
This function requires data that crosses the boundary be <code>UnwindSafe</code>, making <code>&amp;</code> and <code>&amp;mut</code> not valid data types.
Papyrus uses <code>AssertUnwindSafe</code> wrappers to make this work, however it makes <code>app_data</code> vulnerable to breaking
invariant states if a panic is triggered.</p>
<p>The developer should keep this in mind when implementing a linked REPL. 
Some guidelines:</p>
<ol>
<li>Keep the app_data that is being transfered simple.</li>
<li>Develop wrappers that only pass through a <em>clone</em> of the data.</li>
</ol>
<h2><a class="header" href="#dependency-duplication" id="dependency-duplication">Dependency Duplication</a></h2>
<p>When linking an external library, the <code>deps</code> folder is linked to ensure that the dependencies that
the library is built with link properly. There are specific use cases where the rust compiler will
be unable to determine what dependencies to use. This happens when:</p>
<ul>
<li>The library has a dependency <code>depx</code></li>
<li>The REPL is asked to use a dependency <code>depx</code></li>
<li>The library and REPL both use the <em>exact same dependency structure</em> for <code>depx</code>
<ul>
<li>This means that <code>depx</code> is the same version, and has the same feature set enabled</li>
</ul>
</li>
<li>The library and REPL both <em>use</em> the dependency in code</li>
</ul>
<p>As an example, the use of the <code>rand</code> crate might cause compilation issues to arise if the linked
external library also relies of <code>rand</code>. The exact cause is having both crates in the dependency
graph that rustc cannot discern between. The compilation error is however a good indication that
the external library needs to be supplying these transitive dependencies for the REPL's use, as the
REPL is really using the external library as a dependency (just in an indirect manner).
Usually an error message such as <code>error[E0523]: found two different crates with name </code>rand<code> that are not distinguished by differing -C metadata. This will result in symbol conflicts between the two.</code> would be encountered.</p>
<p>To solve this issue, any REPL dependency that could overlap with a library dependency be exposed by
the <em>library itself</em>. This can be done by using <code>pub use depx;</code> or <code>pub extern crate depx;</code> in the
root of the library source. Then, alter the <code>persistent_module_code</code> on the linking configuration
to include a statement such as <code>use external_lib::depx;</code> where the external lib is your library
name. If you library had the name <code>awesome</code> and you wanted to expose the <code>rand</code> crate you would add
<code>use awesome::rand;</code> to the <code>persistent_module_code</code> (make sure to test for whitespace and add if
necessary). There is access to the <code>persistent_module_code</code> through the
<a href="crate::repl::ReplData"><code>ReplData</code></a>.</p>
<p>Adding this code effectively aliases the library dependency as if it was a root dependency of the
REPL. This trick is especially important if one is linking a library that makes use of the <code>kserd</code>
crate and has implemented <code>ToKserd</code> so data types can automatically be transferred across the REPL
boundary. The REPL needs to <em>not</em> use the <code>kserd</code> dependency it is using and use the <code>kserd</code>
dependency from the external library. Using <code>use external_lib::kserd;</code> will manage this.</p>
<p>This is also important as then if the user of the REPL wants to implement <code>ToKserd</code> on REPL types,
it will still be using the consistent <code>kserd</code> dependency, although an astute user might try to
implement <code>::kserd::ToKserd</code> which would break! At least at this point it is easy to back out
changes in the temporary REPL session.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
